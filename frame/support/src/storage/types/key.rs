// This file is part of Substrate.

// Copyright (C) 2021 Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Storage key type.

use crate::hash::{ReversibleStorageHasher, StorageHasher, Identity};
use codec::{EncodeLike, FullCodec};
use sp_std::prelude::*;

/// A type used exclusively by storage maps as their key type.
///
/// The final key generated has the following form:
/// ```nocompile
/// Hasher1(encode(key1))
///     ++ Hasher2(encode(key2))
///     ++ ...
///     ++ HasherN(encode(keyN))
/// ```
pub struct Key<Hasher, KeyType, NextKeyGenerator = ()>(
	core::marker::PhantomData<(Hasher, KeyType, NextKeyGenerator)>,
);

/// A type to chain arbitrary number of hashers. Primarily used for
/// migrating old hashers to new hashers in StorageNMap.
pub struct KeyHasher<Hasher, NextHasherGenerator = ()>(
	core::marker::PhantomData<(Hasher, NextHasherGenerator)>,
);

pub trait KeyHasherGenerator {
	/// The current hasher generated by this type
	type CurrentHasher: StorageHasher;
	/// The next chained key hasher
	type NextHasher: KeyHasherGenerator;
}

impl KeyHasherGenerator for KeyHasher<(), ()> {
	type CurrentHasher = Identity;
	type NextHasher = KeyHasher<(), ()>;
}

impl<H: StorageHasher> KeyHasherGenerator for KeyHasher<H, ()> {
	type CurrentHasher = H;
	type NextHasher = KeyHasher<(), ()>;
}

impl<H: StorageHasher, KHG: KeyHasherGenerator> KeyHasherGenerator for KeyHasher<H, KHG> {
	type CurrentHasher = H;
	type NextHasher = KeyHasher<KHG::CurrentHasher, KHG::NextHasher>;
}

/// A trait that contains the current key as an associated type and generates the next key.
pub trait KeyGenerator {
	type CurrentKey: EncodeLike<Self::CurrentKey>;
	type NextKey;

	fn final_key<KArg: EncodeLike<Self::CurrentKey>>(k: &(KArg, Self::NextKey)) -> Vec<u8>;
	fn final_hash<KArg, KHG>(k: &(KArg, Self::NextKey)) -> Vec<u8>
	where
		KArg: EncodeLike<Self::CurrentKey>,
		KHG: KeyHasherGenerator;
}

impl<H: StorageHasher, K: FullCodec> KeyGenerator for Key<H, K, ()> {
	type CurrentKey = K;
	type NextKey = ();

	fn final_key<KArg: EncodeLike<Self::CurrentKey>>((k, _): &(KArg, Self::NextKey)) -> Vec<u8> {
		k.using_encoded(H::hash).as_ref().to_vec()
	}

	fn final_hash<KArg, KHG>((k, _): &(KArg, Self::NextKey)) -> Vec<u8>
	where
		KArg: EncodeLike<Self::CurrentKey>,
		KHG: KeyHasherGenerator,
	{
		k.using_encoded(KHG::CurrentHasher::hash).as_ref().to_vec()
	}
}

impl<H, K, KG> KeyGenerator for Key<H, K, KG>
where
	H: StorageHasher,
	K: FullCodec,
	KG: KeyGenerator,
{
	type CurrentKey = K;
	type NextKey = (KG::CurrentKey, KG::NextKey);

	fn final_key<KArg: EncodeLike<Self::CurrentKey>>((kh, kt): &(KArg, Self::NextKey)) -> Vec<u8> {
		let kh_hashed = kh.using_encoded(H::hash);
		let kt_hashed = KG::final_key(kt);

		let mut final_key = Vec::with_capacity(kh_hashed.as_ref().len() + kt_hashed.len());
		final_key.extend_from_slice(kh_hashed.as_ref());
		final_key.extend_from_slice(kt_hashed.as_ref());
		final_key
	}

	fn final_hash<KArg, KHG>((kh, kt): &(KArg, Self::NextKey)) -> Vec<u8>
	where
		KArg: EncodeLike<Self::CurrentKey>,
		KHG: KeyHasherGenerator,
	{
		let kh_hashed = kh.using_encoded(KHG::CurrentHasher::hash);
		let kt_hashed = KG::final_hash::<KG::CurrentKey, KHG::NextHasher>(kt);

		let mut final_key = Vec::with_capacity(kh_hashed.as_ref().len() + kt_hashed.len());
		final_key.extend_from_slice(kh_hashed.as_ref());
		final_key.extend_from_slice(kt_hashed.as_ref());
		final_key
	}
}

/// A trait that indicates the hashers for the keys generated are all reversible.
pub trait ReversibleKeyGenerator: KeyGenerator {
	type CurrentHasher: ReversibleStorageHasher;
	fn decode_final_key(key_material: &[u8]) -> Result<(Self::CurrentKey, Self::NextKey), codec::Error>;
}

impl<H: ReversibleStorageHasher, K: FullCodec> ReversibleKeyGenerator for Key<H, K, ()> {
	type CurrentHasher = H;

	fn decode_final_key(key_material: &[u8]) -> Result<(Self::CurrentKey, Self::NextKey), codec::Error> {
		let mut current_key_material = Self::CurrentHasher::reverse(key_material);
		let key = K::decode(&mut current_key_material)?;
		Ok((key, ()))
	}
}

impl<H, K, RKG> ReversibleKeyGenerator for Key<H, K, RKG>
where
	H: ReversibleStorageHasher,
	K: FullCodec,
	RKG: ReversibleKeyGenerator,
{
	type CurrentHasher = H;

	fn decode_final_key(key_material: &[u8]) -> Result<(Self::CurrentKey, Self::NextKey), codec::Error> {
		let mut current_key_material = Self::CurrentHasher::reverse(key_material);
		let key = K::decode(&mut current_key_material)?;
		let next_key = RKG::decode_final_key(current_key_material)?;
		Ok((key, next_key))
	}
}
