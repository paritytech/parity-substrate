//! Combines [substrate_rpc_api::state::StateClient] with [srml_support::storage::generator] traits
//! to provide strongly typed chain state queries over rpc.

use futures::compat::Future01CompatExt;
use jsonrpc_client_transports::RpcError;
use parity_scale_codec::{DecodeAll, FullCodec};
use serde::{de::DeserializeOwned, Serialize};
use srml_support::storage::generator::{
    StorageDoubleMap, StorageLinkedMap, StorageMap, StorageValue,
};
use substrate_primitives_storage::{StorageData, StorageKey};
use substrate_rpc_api::state::StateClient;

/// Queries a typed global from chain state.
///
/// # Arguments
///
/// `state_client` is a json rpc client generated by in the [substrate_rpc_api::state] module
/// using [jsonrpc_derive::rpc].
///
/// `block_index` specifies the block for which storage is to be queried. If None, the latest block
/// is queried.
///
/// # Template Arguments
///
/// `St` is a type implementing [StorageValue]. You usually shouldn't implement this type manually.
/// Instead use the implementations generated by the [srml_support::decl_storage] macro.
///
/// `T` is the type pointed to by SV.
///
/// `Hash` is the block hash type for your runtime, used for specifying a particular block.
/// `Hash = <YourRuntime as srml_system::Trait>::Hash`
///
/// ```no_run
/// # use jsonrpc_client_transports::RpcError;
/// # use futures::compat::Compat;
/// # use futures::future::FutureExt;
/// #
/// # fn main() -> Result<(), RpcError> {
/// #     tokio::runtime::Runtime::new().unwrap().block_on(Compat::new(test().boxed()))
/// # }
/// # async fn test() -> Result<(), RpcError> {
/// use substrate_rpc_custom::storage_value;
/// use substrate_test_runtime::Runtime;
/// use substrate_test_runtime::system::Authorities;
/// use substrate_rpc_api::state::StateClient;
/// use jsonrpc_client_transports::transports::http;
/// use futures::compat::Future01CompatExt;
/// type Hash = <Runtime as srml_system::Trait>::Hash;
///
/// let conn = http::connect("http://[::1]:9933").compat().await?;
/// let cl = StateClient::<Hash>::new(conn);
/// let ret: Option<Vec<_>> = storage_value::<Authorities, _, _>(&cl, None).await?;
/// # Ok(())
/// # }
/// ```
///
/// # Note
///
/// Storage items declared using the [srml_support::decl_storage] won't be accessable unless they
/// are declared public.
///
/// ```
/// # use srml_support::decl_storage;
/// # use srml_support::decl_module;
/// # use parity_scale_codec::Encode;
/// # use srml_system::Trait;
/// #
/// # struct TestRuntime;
/// #
/// # decl_module! {
///	#     pub struct Module<T: Trait> for enum Call where origin: T::Origin {}
/// # }
/// #
/// // Answers is private.
/// decl_storage! {
///     trait Store for Module<T: Trait> as TestRuntime {
///         Answers: Vec<bool>;
///     }
/// }
/// #
/// # fn main() {}
/// ```
///
/// ```
/// # use srml_support::decl_storage;
/// # use srml_support::decl_module;
/// # use parity_scale_codec::Encode;
/// # use srml_system::Trait;
/// #
/// # struct TestRuntime;
/// #
/// # decl_module! {
///	#     pub struct Module<T: Trait> for enum Call where origin: T::Origin {}
/// # }
/// #
/// // Use this instead.
/// decl_storage! {
///     trait Store for Module<T: Trait> as TestRuntime {
///         pub Answers: Vec<bool>;
///     }
/// }
/// #
/// # fn main() {}
/// ```
pub async fn storage_value<
    St: StorageValue<T>,
    T: FullCodec,
    Hash: Send + Sync + 'static + DeserializeOwned + Serialize,
>(
    state_client: &StateClient<Hash>,
    block_index: Option<Hash>,
) -> Result<Option<T>, RpcError> {
    storage_get(
        state_client,
        StorageKey(St::storage_value_final_key().to_vec()),
        block_index,
    )
    .await
}

/// Uses a typed key to query a typed value from chain state.
///
/// ```no_run
/// # use srml_support::decl_storage;
/// # use srml_support::decl_module;
/// # use parity_scale_codec::Encode;
/// # use srml_system::Trait;
/// # use substrate_rpc_custom::storage_map_value;
/// # use substrate_rpc_api::state::StateClient;
/// # use jsonrpc_core::futures::Future;
/// # use jsonrpc_client_transports::transports::http;
/// # use jsonrpc_client_transports::RpcError;
/// # use futures::compat::Compat;
/// # use futures::future::FutureExt;
/// # use futures::compat::Future01CompatExt;
/// #
/// # // Hash would normally be <TestRuntime as srml_system::Trait>::Hash, but we don't have
/// # // srml_system::Trait implemented for TestRuntime. Here we just pretend.
/// # type Hash = ();
/// #
/// # fn main() -> Result<(), RpcError> {
/// #     tokio::runtime::Runtime::new().unwrap().block_on(Compat::new(test().boxed()))
/// # }
/// #
/// # struct TestRuntime;
/// #
/// # decl_module! {
///	#     pub struct Module<T: Trait> for enum Call where origin: T::Origin {}
/// # }
/// #
/// decl_storage! {
///     trait Store for Module<T: Trait> as TestRuntime {
///         pub Voxels: map (i64, i64, i64) => u8;
///     }
/// }
///
/// # async fn test() -> Result<(), RpcError> {
/// let conn = http::connect("http://[::1]:9933").compat().await?;
/// let cl = StateClient::<Hash>::new(conn);
/// let loc = (0, 0, 0);
/// let ret: Option<u8> = storage_map_value::<Voxels, _, _, _>(&cl, loc, None).await?;
/// # Ok(())
/// # }
/// ```
pub async fn storage_map_value<
    St: StorageMap<K, V>,
    K: FullCodec,
    V: FullCodec,
    Hash: Send + Sync + 'static + DeserializeOwned + Serialize,
>(
    state_client: &StateClient<Hash>,
    key: K,
    block_index: Option<Hash>,
) -> Result<Option<V>, RpcError> {
    storage_get(
        state_client,
        StorageKey(St::storage_map_final_key(key).as_ref().to_vec()),
        block_index,
    )
    .await
}

/// Uses a typed key to query a typed value from chain state.
///
/// ```no_run
/// # use srml_support::decl_storage;
/// # use srml_support::decl_module;
/// # use parity_scale_codec::Encode;
/// # use srml_system::Trait;
/// # use substrate_rpc_custom::storage_linked_map_value;
/// # use substrate_rpc_api::state::StateClient;
/// # use jsonrpc_core::futures::Future;
/// # use jsonrpc_client_transports::transports::http;
/// # use jsonrpc_client_transports::RpcError;
/// # use futures::compat::Compat;
/// # use futures::future::FutureExt;
/// # use futures::compat::Future01CompatExt;
/// #
/// # // Hash would normally be <TestRuntime as srml_system::Trait>::Hash, but we don't have
/// # // srml_system::Trait implemented for TestRuntime. Here we just pretend.
/// # type Hash = ();
/// #
/// # fn main() -> Result<(), RpcError> {
/// #     tokio::runtime::Runtime::new().unwrap().block_on(Compat::new(test().boxed()))
/// # }
/// #
/// # struct TestRuntime;
/// #
/// # decl_module! {
///	#     pub struct Module<T: Trait> for enum Call where origin: T::Origin {}
/// # }
/// #
/// decl_storage! {
///     trait Store for Module<T: Trait> as TestRuntime {
///         pub Voxels: linked_map (i64, i64, i64) => u8;
///     }
/// }
///
/// # async fn test() -> Result<(), RpcError> {
/// let conn = http::connect("http://[::1]:9933").compat().await?;
/// let cl = StateClient::<Hash>::new(conn);
/// let loc = (0, 0, 0);
/// let ret: Option<u8> = storage_linked_map_value::<Voxels, _, _, _>(&cl, loc, None).await?;
/// # Ok(())
/// # }
/// ```
pub async fn storage_linked_map_value<
    St: StorageLinkedMap<K, V>,
    K: FullCodec,
    V: FullCodec,
    Hash: Send + Sync + 'static + DeserializeOwned + Serialize,
>(
    state_client: &StateClient<Hash>,
    key: K,
    block_index: Option<Hash>,
) -> Result<Option<V>, RpcError> {
    storage_get(
        state_client,
        StorageKey(St::storage_linked_map_final_key(key).as_ref().to_vec()),
        block_index,
    )
    .await
}

/// Uses two typed keys to query a typed value from chain state.
///
/// ```no_run
/// # use srml_support::decl_storage;
/// # use srml_support::decl_module;
/// # use parity_scale_codec::Encode;
/// # use srml_system::Trait;
/// # use substrate_rpc_custom::storage_double_map_value;
/// # use substrate_rpc_api::state::StateClient;
/// # use jsonrpc_core::futures::Future;
/// # use jsonrpc_client_transports::transports::http;
/// # use jsonrpc_client_transports::RpcError;
/// # use futures::compat::Compat;
/// # use futures::future::FutureExt;
/// # use futures::compat::Future01CompatExt;
/// #
/// # // Hash would normally be <TestRuntime as srml_system::Trait>::Hash, but we don't have
/// # // srml_system::Trait implemented for TestRuntime. Here we just pretend.
/// # type Hash = ();
/// #
/// # fn main() -> Result<(), RpcError> {
/// #     tokio::runtime::Runtime::new().unwrap().block_on(Compat::new(test().boxed()))
/// # }
/// #
/// # struct TestRuntime;
/// #
/// # decl_module! {
///	#     pub struct Module<T: Trait> for enum Call where origin: T::Origin {}
/// # }
/// #
/// decl_storage! {
///     trait Store for Module<T: Trait> as TestRuntime {
///         pub ChunkedVoxels: double_map (u64, u64, u64), blake2_256(u16) => u8;
///     }
/// }
///
/// # async fn test() -> Result<(), RpcError> {
/// let conn = http::connect("http://[::1]:9933").compat().await?;
/// let cl = StateClient::<Hash>::new(conn);
/// let chunk = (0, 0, 0);
/// let block_index = 63999;
/// let ret: Option<u8> =
///     storage_double_map_value::<ChunkedVoxels, _, _, _, _>(&cl, chunk, block_index, None)
///         .await?;
/// # Ok(())
/// # }
/// ```
pub async fn storage_double_map_value<
    St: StorageDoubleMap<K1, K2, V>,
    K1: FullCodec,
    K2: FullCodec,
    V: FullCodec,
    Hash: Send + Sync + 'static + DeserializeOwned + Serialize,
>(
    state_client: &StateClient<Hash>,
    key1: K1,
    key2: K2,
    block_index: Option<Hash>,
) -> Result<Option<V>, RpcError> {
    storage_get(
        state_client,
        StorageKey(St::storage_double_map_final_key(key1, key2)),
        block_index,
    )
    .await
}

/// Lookup a typed value from storage using an encoded key.
async fn storage_get<V: FullCodec, Hash: Send + Sync + 'static + DeserializeOwned + Serialize>(
    state_client: &StateClient<Hash>,
    key: StorageKey,
    block_index: Option<Hash>,
) -> Result<Option<V>, RpcError> {
    let opt: Option<StorageData> = state_client.storage(key, block_index).compat().await?;
    opt.map(|storage_data| V::decode_all(&storage_data.0))
        .transpose()
        .map_err(|decode_err| RpcError::Other(decode_err.into()))
}
